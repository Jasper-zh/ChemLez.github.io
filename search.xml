<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习:决策树入门之泰坦尼克号案例</title>
      <link href="/2020/02/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E6%A1%88%E4%BE%8B/"/>
      <url>/2020/02/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%E5%85%A5%E9%97%A8%E4%B9%8B%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>本文用于记录机器学习中的一次入门练习，即：利用决策树进行简单的二分类。同时，结合Kaggle上的经典案例Titanic，来测试实际效果。</p><h1 id="一、数据集"><a href="#一、数据集" class="headerlink" title="一、数据集"></a>一、数据集</h1><p>采用<a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">Kaggle</a>中的Titanic的数据集。数据包含分为：  </p><ul><li>训练集: training set (train.csv)</li><li>测试集: test set (test.csv)</li><li>提交标准: gender_submission.csv  </li></ul><p>由于Kaggle涉及到科学上网的操作，所以<a href="https://github.com/ChemLez/ML-sklearn/tree/master/1-%20DecisionTree" target="_blank" rel="noopener">原始数据集</a>已经下载好放在Gighub上了。</p><h1 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h1><p>首先导入训练集，查看数据的情况：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier <span class="comment"># 导入模型决策树分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score,train_test_split,GridSearchCV <span class="comment"># 导入的模型作用分别为交叉验证、训练集与数据集的划分，网格搜索</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">'/Users/liz/code/jupyter-notebook/sklearn/1- DecisionTree/Titanic_train.csv'</span>) <span class="comment"># 导入数据集</span></span><br><span class="line">data.head() <span class="comment"># 显示数据集的前五行</span></span><br><span class="line">[out]:</span><br></pre></td></tr></table></figure><a id="more"></a><overflow><table><thead><tr><th></th><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SlibSp</th><th>Parch</th><th>Ticek</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>3</td><td>Braund, Mr. Owen Harris</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.2500</td><td>NaN</td><td>S</td></tr><tr><td>1</td><td>2</td><td>1</td><td>1</td><td>Cumings, Mrs. John Bradley (Florence Briggs Th…</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td></tr><tr><td>2</td><td>3</td><td>1</td><td>3</td><td>Heikkinen, Miss. Laina</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.9250</td><td>NaN</td><td>S</td></tr><tr><td>3</td><td>4</td><td>1</td><td>1</td><td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>113803</td><td>53.1000</td><td>C123</td><td>S</td></tr><tr><td>4</td><td>5</td><td>0</td><td>3</td><td>Allen, Mr. William Henry</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>373450</td><td>8.0500</td><td>NaN</td><td>S</td></tr></tbody></table></overflow><p>通过以上的数据所展示的情况，我们所要做的是将Survived作为标签，其余的列作为特征。目标：以所知的特征来预测标签。这份数据集的实际意义是:通过已知数据对乘客的生还情况做一次预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data.info() <span class="comment"># 查看整个训练集的情况</span></span><br><span class="line">out:</span><br><span class="line"> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class">    <span class="title">RangeIndex</span>:</span> <span class="number">891</span> entries, <span class="number">0</span> to <span class="number">890</span></span><br><span class="line">    Data columns (total <span class="number">12</span> columns):</span><br><span class="line">    PassengerId    <span class="number">891</span> non-null int64</span><br><span class="line">    Survived       <span class="number">891</span> non-null int64</span><br><span class="line">    Pclass         <span class="number">891</span> non-null int64</span><br><span class="line">    Name           <span class="number">891</span> non-null object</span><br><span class="line">    Sex            <span class="number">891</span> non-null object</span><br><span class="line">    Age            <span class="number">714</span> non-null float64</span><br><span class="line">    SibSp          <span class="number">891</span> non-null int64</span><br><span class="line">    Parch          <span class="number">891</span> non-null int64</span><br><span class="line">    Ticket         <span class="number">891</span> non-null object</span><br><span class="line">    Fare           <span class="number">891</span> non-null float64</span><br><span class="line">    Cabin          <span class="number">204</span> non-null object</span><br><span class="line">    Embarked       <span class="number">889</span> non-null object</span><br><span class="line">    dtypes: float64(<span class="number">2</span>), int64(<span class="number">5</span>), object(<span class="number">5</span>)</span><br><span class="line">    memory usage: <span class="number">83.7</span>+ KB</span><br></pre></td></tr></table></figure><h5 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h5><ol><li>通过以上的数据展示，共有891条数据，其中具有缺失值的特征有：Age、Cabin、Embarked；非数值型的特征有：Name,Sex,Ticket,Cabin,Embarked。</li><li>当我们采用现有的特征对乘客进行生还情况预测时，一些处理较为麻烦且不太重要的特征对可不采用。例如：这里的Name、Ticket可以不采用，因为在实际情况中乘客的名字以及所购的票对于乘客的生还情况作用不大。另外一点原因是这两者皆为非数值型数据，处理成数值形式较为复杂（在计算机中所接受的数据最终都要以数字的形式进行呈现）。</li><li>由于Cabin缺失值较多，这里采用删除的方式，理由同上。</li><li>虽然性别也为字符型数据，当在实际中性别对于逃生的可能性具有一定的影响，故对其保留。</li><li>将缺失值进行填补；将非数值型数据转化为数值型数据。    </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除Name、Ticket、Cabin特征列</span></span><br><span class="line">data.drop([<span class="string">'Name'</span>,<span class="string">'Cabin'</span>,<span class="string">'Ticket'</span>],inplace=<span class="literal">True</span>,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失值的填补</span></span><br><span class="line"><span class="comment"># 对于Age的缺失值填补的一种策略为：以年龄的平均值作为填补</span></span><br><span class="line">data.loc[:,<span class="string">'Age'</span>] = data[<span class="string">'Age'</span>].fillna(int(data[<span class="string">'Age'</span>].mean()))</span><br><span class="line"><span class="comment"># Embarked由于只有两条数据具有缺失值，这里采用的方式是删除这两条缺失的数据（缺失两条数据对模型的训练好坏影响不大）</span></span><br><span class="line">data = data.dropna()</span><br><span class="line">data = data.reset_index(drop = <span class="literal">True</span>) <span class="comment"># 删除过后，用于重置索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将非数值型数据转化为数值型数据</span></span><br><span class="line"><span class="comment"># 性别只有两类，故可用0\1来表示男女</span></span><br><span class="line">data[<span class="string">'Sex'</span>] = (data[<span class="string">'Sex'</span>] == <span class="string">'male'</span>).astype(int) <span class="comment"># 0表示女，1表示男</span></span><br><span class="line">tags = data[<span class="string">'Embarked'</span>].unique().tolist() <span class="comment"># tags: ['S', 'C', 'Q']</span></span><br><span class="line"><span class="comment"># Embarked只有三类分别以S,C,Q的索引代表他们,0~9均可采用此种方法</span></span><br><span class="line">data.iloc[:,data.columns == <span class="string">'Embarked'</span>] = data[<span class="string">'Embarked'</span>].apply(<span class="keyword">lambda</span> x : tags.index(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">data.info() <span class="comment"># 查看数据信息</span></span><br><span class="line">out:</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">889</span> entries, <span class="number">0</span> to <span class="number">888</span></span><br><span class="line">Data columns (total <span class="number">9</span> columns):</span><br><span class="line">PassengerId    <span class="number">889</span> non-null int64</span><br><span class="line">Survived       <span class="number">889</span> non-null int64</span><br><span class="line">Pclass         <span class="number">889</span> non-null int64</span><br><span class="line">Sex            <span class="number">889</span> non-null int64</span><br><span class="line">Age            <span class="number">889</span> non-null float64</span><br><span class="line">SibSp          <span class="number">889</span> non-null int64</span><br><span class="line">Parch          <span class="number">889</span> non-null int64</span><br><span class="line">Fare           <span class="number">889</span> non-null float64</span><br><span class="line">Embarked       <span class="number">889</span> non-null int64</span><br><span class="line">dtypes: float64(<span class="number">2</span>), int64(<span class="number">7</span>)</span><br><span class="line">memory usage: <span class="number">62.6</span> KB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将特征与标签进行分离</span></span><br><span class="line">x = data.iloc[:,data.columns != <span class="string">'Survived'</span>] <span class="comment"># 取出Survived以为的列作为特征x</span></span><br><span class="line">y = data.iloc[:,data.columns == <span class="string">'Survived'</span>] <span class="comment"># 取出Survived列作为特征y</span></span><br></pre></td></tr></table></figure><h5 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h5><p>思路：采用交叉验证来评估我们的模型；同时采用网格搜索来查找决策树中常见的最佳参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网格搜索：能够帮助我们同时调整多个参数的技术，本质是枚举技术。</span></span><br><span class="line"><span class="comment"># paramerters：用于确定的参数。</span></span><br><span class="line">parameters = &#123;<span class="string">'splitter'</span>:(<span class="string">'best'</span>,<span class="string">'random'</span>)</span><br><span class="line">             ,<span class="string">'criterion'</span>:(<span class="string">'gini'</span>,<span class="string">'entropy'</span>)</span><br><span class="line">             ,<span class="string">'max_depth'</span>:[*range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">             ,<span class="string">'min_samples_leaf'</span>:[*range(<span class="number">1</span>,<span class="number">50</span>,<span class="number">5</span>)]</span><br><span class="line">             ,<span class="string">'min_impurity_decrease'</span>:[*np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">20</span>)]</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网格搜索实例代码，所需要确定的参数越多，耗时越长</span></span><br><span class="line">clf = DecisionTreeClassifier(random_state=<span class="number">30</span>)</span><br><span class="line">GS = GridSearchCV(clf,parameters,cv=<span class="number">10</span>) <span class="comment"># cv=10,做10次交叉验证</span></span><br><span class="line">GS = GS.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line">GS.best_params_</span><br><span class="line">out:</span><br><span class="line">    &#123;<span class="string">'criterion'</span>: <span class="string">'gini'</span>,</span><br><span class="line"> <span class="string">'max_depth'</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">'min_impurity_decrease'</span>: <span class="number">0.0</span>,</span><br><span class="line"> <span class="string">'min_samples_leaf'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'splitter'</span>: <span class="string">'best'</span>&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 最佳得分</span></span><br><span class="line">GS.best_score_</span><br></pre></td></tr></table></figure><p>确定了设置的参数的最佳值，开始训练模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型，将以上设置参数的最佳值填入模型的实例化中</span></span><br><span class="line">clf_model = DecisionTreeClassifier(criterion=<span class="string">'gini'</span></span><br><span class="line">                                  ,max_depth=<span class="number">3</span></span><br><span class="line">                                  ,min_samples_leaf=<span class="number">1</span></span><br><span class="line">                                  ,min_impurity_decrease=<span class="number">0</span></span><br><span class="line">                                  ,splitter=<span class="string">'best'</span></span><br><span class="line">                                  )</span><br><span class="line">clf_model = clf_model.fit(x,y)</span><br></pre></td></tr></table></figure><p>导出模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出模型</span></span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(clf_model,<span class="string">'/Users/liz/Code/jupyter-notebook/sklearn/1- DecisionTree/clf_model.m'</span>)</span><br></pre></td></tr></table></figure><p>测试集的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入测试集</span></span><br><span class="line">data_test = pd.read_csv(<span class="string">'/Users/liz/code/jupyter-notebook/sklearn/1- DecisionTree/Titanic_test.csv'</span>)</span><br><span class="line">data_test.info()</span><br><span class="line">out:</span><br><span class="line">    &lt;<span class="class"><span class="keyword">class</span> '<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>'&gt;</span></span><br><span class="line"><span class="class">    <span class="title">RangeIndex</span>:</span> <span class="number">418</span> entries, <span class="number">0</span> to <span class="number">417</span></span><br><span class="line">    Data columns (total <span class="number">11</span> columns):</span><br><span class="line">    PassengerId    <span class="number">418</span> non-null int64</span><br><span class="line">    Pclass         <span class="number">418</span> non-null int64</span><br><span class="line">    Name           <span class="number">418</span> non-null object</span><br><span class="line">    Sex            <span class="number">418</span> non-null object</span><br><span class="line">    Age            <span class="number">332</span> non-null float64</span><br><span class="line">    SibSp          <span class="number">418</span> non-null int64</span><br><span class="line">    Parch          <span class="number">418</span> non-null int64</span><br><span class="line">    Ticket         <span class="number">418</span> non-null object</span><br><span class="line">    Fare           <span class="number">417</span> non-null float64</span><br><span class="line">    Cabin          <span class="number">91</span> non-null object</span><br><span class="line">    Embarked       <span class="number">418</span> non-null object</span><br><span class="line">    dtypes: float64(<span class="number">2</span>), int64(<span class="number">4</span>), object(<span class="number">5</span>)</span><br><span class="line">    memory usage: <span class="number">36.0</span>+ KB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集处理的方法同训练集，同时测试集要与训练集保持同样的特征</span></span><br><span class="line"><span class="comment"># 由于最后，我们需要将处理结果上传到Kaggle上，所以不能够将数据条目减少，即：需要上传418条测试数据；故这里Fare缺失的一条数目同样采用平均值来填补</span></span><br><span class="line">data_test.drop([<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],inplace=<span class="literal">True</span>,axis=<span class="number">1</span>)</span><br><span class="line">data_test[<span class="string">'Age'</span>] = data_test[<span class="string">'Age'</span>].fillna(int(data_test[<span class="string">'Age'</span>].mean()))</span><br><span class="line">data_test[<span class="string">'Fare'</span>] = data_test[<span class="string">'Fare'</span>].fillna(int(data_test[<span class="string">'Fare'</span>].mean()))</span><br><span class="line">data_test.loc[:,<span class="string">'Sex'</span>] = (data_test[<span class="string">'Sex'</span>] == <span class="string">'male'</span>).astype(int)</span><br><span class="line">tags = data_test[<span class="string">'Embarked'</span>].unique().tolist()</span><br><span class="line">data_test[<span class="string">'Embarked'</span>] = data_test[<span class="string">'Embarked'</span>].apply(<span class="keyword">lambda</span> x : tags.index(x))</span><br></pre></td></tr></table></figure><p>此时测试集数据预处理完毕，导出模型并对数据进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出模型且测试数据集</span></span><br><span class="line">model = joblib.load(<span class="string">'/Users/liz/Code/jupyter-notebook/sklearn/1- DecisionTree/clf_model.m'</span>)</span><br><span class="line">Survived = model.predict(data_test) <span class="comment"># 测试结果</span></span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">Survived = pd.DataFrame(&#123;<span class="string">'Survived'</span>:Survived&#125;) <span class="comment"># 将结果转换为字典形式并后续作为csv形式导出</span></span><br><span class="line">PassengerId = data_test.iloc[:,data_test.columns == <span class="string">'PassengerId'</span>] <span class="comment"># 切片，分割出PassengerId</span></span><br><span class="line">gender_submission = pd.concat([PassengerId,Survived],axis=<span class="number">1</span>)<span class="comment"># 将Survived与PassengerId拼接，一一对应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导出数据</span></span><br><span class="line"><span class="comment">#导出数据</span></span><br><span class="line">gender_submission.index = np.arange(<span class="number">1</span>, len(gender_submission)+<span class="number">1</span>) <span class="comment"># 索引从1开始</span></span><br><span class="line">gender_submission.to_csv(<span class="string">'/Users/liz/Code/jupyter-notebook/sklearn/1- DecisionTree/gender_submission.csv'</span>,index=<span class="literal">False</span>) <span class="comment"># index=False，导出时不显示索引</span></span><br></pre></td></tr></table></figure><p>导出文件:</p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>892</td>      <td>0</td>    </tr>    <tr>      <td>1</td>      <td>893</td>      <td>1</td>    </tr>    <tr>      <td>2</td>      <td>894</td>      <td>0</td>    </tr>    <tr>      <td>3</td>      <td>895</td>      <td>0</td>    </tr>    <tr>      <td>4</td>      <td>896</td>      <td>1</td>    </tr>    <tr>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <td>413</td>      <td>1305</td>      <td>0</td>    </tr>    <tr>      <td>414</td>      <td>1306</td>      <td>1</td>    </tr>    <tr>      <td>415</td>      <td>1307</td>      <td>0</td>    </tr>    <tr>      <td>416</td>      <td>1308</td>      <td>0</td>    </tr>    <tr>      <td>417</td>      <td>1309</td>      <td>0</td>    </tr>  </tbody></table><p>418 rows × 2 columns</p><p>将结果提交到<a href="https://www.kaggle.com/c/titanic" target="_blank" rel="noopener">Kaggle</a>上，最终得分：</p><p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/02/09/1WxMnK.png" alt="得分"></p><p>最终得分0.77990，分数不高，最高有得满分的，此篇只是作为机器学习及Kaggle的一个入门。</p><p>最终的源代码及Kaggle的数据集都会上传到我的Github仓库中，其中也包括一些网络上搬运的相关笔记也都会上传到Github上,此仓库会持续更新…</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><btns rounded grid5><a href='https://github.com/ChemLez/ML-sklearn/' target="_blank" rel="noopener"><i class='fas fa-download'></i>下载源码</a></a></btns>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DecisionTree </tag>
            
            <tag> Kaggle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云端MySQL安装及相关配置</title>
      <link href="/2020/01/22/%E4%BA%91%E7%AB%AFMySQL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/22/%E4%BA%91%E7%AB%AFMySQL%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>由于自己的阿里云账号申请不足6个月，能够享受新用户云服务器ECS89元一年的优惠政策，所以就购买了一台云服务器，作为日常学习的使用。本文用来记录此次装载云服务器所遇到的一些问题及MySQL的安装过程。</p><h4 id="一、云服务器的选配及配置"><a href="#一、云服务器的选配及配置" class="headerlink" title="一、云服务器的选配及配置"></a>一、云服务器的选配及配置</h4><p>此次我选购的服务器网址:<a href="http://aliyun.langsan.com/?bd_vid=8575091722087683835" target="_blank" rel="noopener">http://aliyun.langsan.com/?bd_vid=8575091722087683835</a>。下图为此次所购的云服务器配置:  <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1AMtQs.png" alt="服务器配置"> </p><a id="more"></a><p>后续步骤为：提货券的兑换；地域站点的选取以及系统的选配。这里我选取的为上海的站点（大陆境内站点随便选没什么差别），系统选装的为Centos7(具体到7.x没什么区别)。然后就是阿里云那边的自动配置了。购买及配置较为简单，全部为阿里云的傻瓜一站式操作。</p><h4 id="二、安全组的设置"><a href="#二、安全组的设置" class="headerlink" title="二、安全组的设置"></a>二、安全组的设置</h4><p>第一次服务器的使用，需要进行安全组的设置。进入到自己的控制台-实例与镜像-实例。这个时候就能够看到自己的服务器。勾选此台服务器：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1AlfPO.png" alt="">  </p><ul><li><p>依次设置实例ID、重置实例密码；  </p></li><li><p>在更多选项中选择密码/密匙。重置远程连接的密码。  </p><p><strong>注</strong>:实例密码为操作系统的密码，即为root用户名密码。在实例创建时可选设定，如果没有设定或者遗忘可在阿里云的个人控制台上进行密码重置操作；远程链接密码是通过个人后台控制面板，通过内网形式直接链接到操作系统上，这种链接方式可以绕过安全组拦截，一般用于安全组将远程端口拦截时选择此种方法。  </p></li><li><p>网络与安全组。将此实例加入到安全组里。  </p></li><li><p>设置安全组规则  <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1A3K1g.png" alt="">  在安全组规则中，采用快速创建规则。规则方向：入方向/出方向，均可采用，用于控制服务器访入与访出。授权策略：允许/禁止（不解释）。常用端口（TCP）:控制端口的访入与访出（根据自己的习惯与用处）。授权对象:默认为0.0.0.0/0。至此服务器基本配置到此结束。<br>回到控制台实例中，点击远程连接。区域即为所选区域（一般默认不变）；端口默认为22；用户名默认为root；密码是之前设置的实例密码。</p></li></ul><h4 id="三、本机ssh连接服务器免密设置"><a href="#三、本机ssh连接服务器免密设置" class="headerlink" title="三、本机ssh连接服务器免密设置"></a>三、本机ssh连接服务器免密设置</h4><p>上一部分中，我们在阿里云的网页实例中，远程连接到我们的服务器。但是，每当我们需要用到服务器时，便要通过阿里云账号登录再来连接就显得比较麻烦。这里，通过ssh的命令在自己电脑终端来远程连接自己的服务器。<br>终端命令：<code>ssh root@ip</code>  </p><ul><li>root:远程连接的用户名；一般默认不变即为root。  </li><li>ip:自己服务器公网ip。<br>回车后，输入自己的root用户实例密码即可连接。<br><strong>注：Linux、Mac系统终端自带ssh命令；Windows系统不自带ssh命令，需要借助putty或Xshell客户端软件使用。</strong><br>但是，每次我们在自己的电脑连接到服务器都需要通过ip地址，再由密码登录也比较麻烦。所以这里再介绍本机免密码登录服务器的方式。<br>思路：将自己的公有密匙添加到服务器端。  </li></ul><h5 id="1-在本地生成一对公匙-密匙"><a href="#1-在本地生成一对公匙-密匙" class="headerlink" title="1.在本地生成一对公匙-密匙"></a>1.在本地生成一对公匙-密匙</h5><p><code>ssh-keygen -t rsa</code><br>采用默认目录，不设置密码，一路回车即可。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1AYUaR.png" alt="">  最终会在~/.ssh目录下生成id_rsa(密匙)；id_rsa.pub(公匙)。  </p><h5 id="2-将公匙部署至服务器上"><a href="#2-将公匙部署至服务器上" class="headerlink" title="2.将公匙部署至服务器上"></a>2.将公匙部署至服务器上</h5><p>在本地命令执行：<br>方式一:<code>scp ~/.ssh/id_rsa.pub root@公网IP地址:～/.ssh/authorized_keys</code><br>方式二：<code>ssh-copy-id ~/.ssh/id_rsa.pub root@公网IP地址</code><br>以上两种方式即将本地公匙内容复制到远程服务器<code>～/.ssh/authorized_keys</code>的文件中。</p><p>至此，再次登录服务器只需一句ssh终端命令即可，不需要再输入密码。<br>到这里还不是最简洁的一种登录方式，因为我们还需要输入root用户账号，ip地址。所以后续还有更简洁的方式：<br>本地需要保存ssh登录主机的相关信息，在本地主机用户根目录下的.ssh文件内创建config文件，用于保存ssh登陆主机的相关信息<br><code>vim config</code>（如果没有vim可以手动到此目下创建config文件）<br>编辑内容：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host name #AAAAA为服务器主机名</span><br><span class="line">HostName 39.97.170.231 #写服务器ip地址</span><br><span class="line">User root #root为登陆用户名</span><br><span class="line">Port 22 #主机端口，默认是22</span><br><span class="line">IdentityFile &#x2F;Users&#x2F;.ssh&#x2F;id_rsa #自己生成的私钥的文件路径</span><br></pre></td></tr></table></figure><p><strong>注意：Host name是之前服务器设置中设置的实例id/名称</strong><br>实例如下：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1AUC5R.png" alt="">  </p><h5 id="3-在服务器设置自动检验的信息"><a href="#3-在服务器设置自动检验的信息" class="headerlink" title="3.在服务器设置自动检验的信息"></a>3.在服务器设置自动检验的信息</h5><p>打开/etc/ssh/sshd_config文件<br><code>vim /etc/ssh/sshd_config</code>找到  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes </span><br><span class="line">AuthorizedKeysFile .ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>取消注释。<br>至此，以后在自己本机上只需要采用:<code>ssh liz_es</code>即可登录。</p><h4 id="四、-MySQL服务器的安装及相关配置"><a href="#四、-MySQL服务器的安装及相关配置" class="headerlink" title="四、 MySQL服务器的安装及相关配置"></a>四、 MySQL服务器的安装及相关配置</h4><h5 id="MySQ安装"><a href="#MySQ安装" class="headerlink" title="MySQ安装"></a>MySQ安装</h5><p>这一部分记录云服务器端安装MySQL及相关配置</p><ol><li>下载并安装MySQL官方的Yum Repository<br><code>[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</code><br>使用上面的命令直接安装Yum Repository<br><code>[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm</code> </li><li>安装MySQL服务器<br><code>root@localhost ~]# yum -y install mysql-community-server</code><br><code>[root@localhost ~]# yum -y remove mysql57-community-release-el7-10.noarch</code>    </li><li>MySQL数据库设置<br>MySQL的启动<br><code>[root@localhost ~]# systemctl start mysqld.service</code><br>MySQL的关闭<br><code>systemctl stop mysqld.service</code><br>查看MySQL运行状态<br><code>[root@localhost ~]# systemctl status mysqld.service</code><br>查找root初始密码<br><code>[root@localhost ~]# grep &quot;password&quot; /var/log/mysqld.log</code><br>登录MySQL<br><code>mysql -uroot -p</code><br>此时需要修改初始密码才能对数据库进行后续操作。又由于数据库默认的密码强度所设置的密码较为复杂，所以需要事先修改密码强度规则。否则在修改密码的过程容易出现以下错误：<br><code>ERROR 1819 (HY000): Your password does not satisfy the current policy requiremen</code><br>下面列出常用的关于密码设置方面的MySQL操作命令。<br>查看MySQL密码相关的全局参数：<br><code>mysql&gt; select @@validate_password_policy;</code><br><code>mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;</code>  </li></ol><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><p><code>validate_password_dictionary_file</code><br>插件用于验证密码强度的字典文件路径。<br><code>validate_password_length</code> </p><p>密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)<br><code>validate_password_mixed_case_count</code><br>密码至少要包含的小写字母个数和大写字母个数。</p><p><code>validate_password_number_count</code><br>密码至少要包含的数字个数。<br><code>validate_password_policy</code><br>密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG。<br><code>validate_password_special_char_count</code> </p><p>密码至少要包含的特殊字符数。</p><h5 id="修改mysql参数配置"><a href="#修改mysql参数配置" class="headerlink" title="修改mysql参数配置"></a>修改mysql参数配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global validate_password_policy&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.05 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_mixed_case_count&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_number_count&#x3D;5;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_special_char_count&#x3D;0;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; set global validate_password_length&#x3D;2;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)  </span><br><span class="line">  </span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;  </span><br><span class="line">mysql&gt; FLUSH PRIVILEGES</span><br></pre></td></tr></table></figure><p>可能最后两句在执行时，会报错。这是因为还没对初始密码进行修改。在修改完密码以后<code>FLUSH PRIVILEGES</code>，保证密码强度规则的更新。</p><h5 id="MySQL密码的修改"><a href="#MySQL密码的修改" class="headerlink" title="MySQL密码的修改"></a>MySQL密码的修改</h5><p><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;</code>  </p><h5 id="MySQL用户的创建及权限设置"><a href="#MySQL用户的创建及权限设置" class="headerlink" title="MySQL用户的创建及权限设置"></a>MySQL用户的创建及权限设置</h5><p>在MySQL中其实有一个内置且名为mysql的数据库，这个数据库中存储的是MySQL的一些数据，比如用户、权限信息、存储过程等。通过以下命令可查看当前数据库存在哪些用户；<br><code>SELECT User, Host FROM mysql.user;</code><br>可看见如下类似信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+-----------+</span><br><span class="line">| User          | Host      |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| re_mysql      | %         |</span><br><span class="line">| mysql.session | localhost |</span><br><span class="line">| mysql.sys     | localhost |</span><br><span class="line">| root          | localhost |</span><br><span class="line">+---------------+-----------+</span><br></pre></td></tr></table></figure><blockquote><p>Host代表用户所能连接的数据库主机</p><p>% 代表任何主机<br>localhost 代表只能在本机上使用的用户</p></blockquote><ol><li><p>创建用户<br><code>mysql&gt;CREATE USER  &#39;user_name&#39;@&#39;host&#39;  IDENTIFIED BY  &#39;password&#39;;</code><br>user_name:需要创建的用户名称。<br>host:表示要这个新创建的用户允许从哪台机登陆，如果只允许从本机登陆，则填‘localhost’ ；如果指定某台主机登录，则填’ip’;如果允许从任意远程登陆，则填 ‘%’；<br>password:新创建用户的数据库登录密码，需符合密码强度规则。  </p></li><li><p>授权用户<br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;user_name&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><br><code>PRIVILEGES:</code>表示要授予什么权限。例如可以有 select ,insert ,delete,update等,如果要授予全部权力,则填ALL。  </p><p><code>*.*:</code>表示用户的权限能用在哪个库的哪个表中，如果想要用户的权限很作用于所有的数据库所有的表，则填*.*，*是一个通配符，表示全部。<br><code>user_name:</code>所要授权的用户。<br><code>&#39;%&#39;:</code>表面所有远程都可在此用户登录MySQL服务器，具体使用同节。<br><code>WITH GRANT OPTION:</code>用以上命令授权的用户不能给其他用户授权，如果想这个用户能够给其他用户授权，就要在后面加上WITH GRANT OPTION。  </p></li><li><p>删除用户<br><code>DROP  USER ‘user_name’@‘localhost/ip/*’</code>  </p></li><li><p>立即生效<br><code>flush privileges</code>  </p></li><li><p>修改mysql库里边的user表，限制root用户只能从哪个ip登录<br><code>update mysql.user set host=&#39;localhost&#39; where user=&#39;root&#39;;</code></p></li></ol><h4 id="MySQL的远程连接"><a href="#MySQL的远程连接" class="headerlink" title="MySQL的远程连接"></a>MySQL的远程连接</h4><p>云服务器端部署好了MySQL。那么可以在本机中连接云服务器端的MySQL数据库。这里，我借助的是<code>Navicat for MySQL</code>。<br>创建连接：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1AYZrQ.png" alt="">  连接名：随便写。<br>主机：云服务器的公有IP。<br>端口：默认端口3306。<br>用户名:即在上一节中创建的新用户，并且是能够远程连接的用户。<br>编辑密码：MySQL这一用户的密码。<br>点击测试连接。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/22/1ATjbD.png" alt="">  成功！<br>以后便可以在本机连接到服务器端的MySQL进行使用。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>当在虚拟机(Ubuntu16.04)中的MySQL采取同样的操作时，可能连接失败。在百度了一番博文以后，所采用的办法是在虚拟机的终端：  </p><ul><li>cd /etc/mysql 进入到my.cnf文件所在的目录下，sudo cp my.cnf my.cnf.bak，备份文件  </li><li>打开配置，找到bind-address= 127.0.0.1这一行，注释掉。  </li><li>重启数据库，使用Navicat进行连接。  </li></ul><h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><ul><li><p>Markdown常用命令：<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a>  </p></li><li><p>vim常用命令：<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-vim.html</a>  </p></li><li><p>菜鸟：<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a>  </p></li><li><p>免费的图床-路过图床：<a href="https://imgchr.com/" target="_blank" rel="noopener">https://imgchr.com/</a>  </p></li><li><p><a href="https://blog.csdn.net/sunshine940326/article/details/70936988" target="_blank" rel="noopener">hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗?</a>  </p></li><li><p><a href="https://www.jianshu.com/p/271449df801f" target="_blank" rel="noopener">Hexo 教程：Hexo 博客部署到腾讯云教程</a>  </p></li><li><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a>   </p></li><li><p><strong>git 清除缓存</strong></p><blockquote><p>git rm -r –cached .<br>git add .<br>git commit -m ‘update .gitignore’</p></blockquote></li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><blockquote><p>[1] centos7下安装mysql（完整配置）:<a href="https://blog.csdn.net/baidu_32872293/article/details/80557668" target="_blank" rel="noopener">https://blog.csdn.net/baidu_32872293/article/details/80557668</a><br>[2] mysql 密码强度规则设置:<a href="https://blog.csdn.net/u014236541/article/details/78244601" target="_blank" rel="noopener">https://blog.csdn.net/u014236541/article/details/78244601</a><br>[3] MYSQL的创建用户，授权用户，删除用户，查看用户:<a href="https://blog.csdn.net/u014453898/article/details/55064312" target="_blank" rel="noopener">https://blog.csdn.net/u014453898/article/details/55064312</a><br>[4] mysql查看所有用户:<a href="https://blog.csdn.net/qq_37996815/article/details/78934536" target="_blank" rel="noopener">https://blog.csdn.net/qq_37996815/article/details/78934536</a><br>[5] Ubuntu 16.04 安装使用MySQL:<a href="https://blog.csdn.net/vXueYing/article/details/52330180" target="_blank" rel="noopener">https://blog.csdn.net/vXueYing/article/details/52330180</a><br>[6] 使用navicat 连接虚拟机上的MySQL数据库:<a href="https://www.jianshu.com/p/8fa82acb16e9" target="_blank" rel="noopener">https://www.jianshu.com/p/8fa82acb16e9</a><br>[7] SSH连接服务器 本地记住用户名及密码:<a href="https://blog.csdn.net/persist_xyz/article/details/90231433" target="_blank" rel="noopener">https://blog.csdn.net/persist_xyz/article/details/90231433</a></font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Ubuntu的安装与相关设置</title>
      <link href="/2020/01/17/Linux-Ubuntu%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"/>
      <url>/2020/01/17/Linux-Ubuntu%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>近日换了电脑，想装一个Linux系统，但也不想在本机上装双系统，就选择了装起虚拟机。此次选择了安装Ubuntu 16.04.6版本，文章最后会附上常用16.04和18.04ubuntu镜像源下载的网址。本文，用来记录此次虚拟机的装载过程、后续配置。</p><h4 id="一、VMWare-Fusion的下载"><a href="#一、VMWare-Fusion的下载" class="headerlink" title="一、VMWare Fusion的下载"></a>一、VMWare Fusion的下载</h4><p>VMware Fusion是VMware为Macintosh计算机开发的虚拟机管理程序。用来管理虚拟机环境。此次选择了11.5.1的版本-<a href="https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_fusion/11_0" target="_blank" rel="noopener">下载地址</a>。序列号查询百度即可。</p><h4 id="二、Ubuntu的安装"><a href="#二、Ubuntu的安装" class="headerlink" title="二、Ubuntu的安装"></a>二、Ubuntu的安装</h4><p>打开VMWare Fusion，点击创建新环境。选择创建自定义虚拟机安装。这里没有选择上方的镜像安装，是因为我在第一次用这种方法安装完以后，尝试了各种方法却不能安装VMware tools。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lz0DgJ.png" alt="后续步骤1"></p><a id="more"></a> <p>继续下一步<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lz00CF.md.png" alt="后续步骤"><br>选择所要安装的操作系系统，这里为Ubuntu 64位。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lz0d4U.png" alt="后续步骤3"><br>选择UEFI安装模式。后续的步骤中就一路下一步。安装过程中，如果VMware没有检测到我们所需要安装的镜像源，那么需要我们将镜像源手动添加到配置中。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzsri6.png" alt="步骤一"><br>若卡在这里不动，便需要我们手动添加镜像源。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzs2sH.png" alt="步骤二">)<img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzsgQe.png" alt="步骤三"></p><p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzsyRO.png" alt="步骤四"><br>后续就是VMware的全自动配置安装了。<br><font color=red><strong>注意：后续语言环境的安装，请选择默认的English,不要改成简体中文模式。</strong></font>因为，当我们熟练了Linux的终端命令以后，我们就不再进行图形化界面的操作，而是转变为字符界面的操作。如果，开始默认的是中文简体，那么在字符界面中，中文会出现菱形乱码，无法识别。从这里的后续安装可以参考<a href="https://jingyan.baidu.com/article/574c52195de75a6c8d9dc1b8.html" target="_blank" rel="noopener">百度百科</a>。<br>在VMware的一系列自动安装配置以后。若出现了:<img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzc2yF.png" alt="问题1"><br>将上述添加的磁盘勾选取消<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzsgQe.png" alt=""><br>点击虚拟机重启即可！登录，进入图形化界面！<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lz2vGt.png" alt="界面"></p><h4 id="三、Ubuntu的镜像源设置"><a href="#三、Ubuntu的镜像源设置" class="headerlink" title="三、Ubuntu的镜像源设置"></a>三、Ubuntu的镜像源设置</h4><p>这里介绍两种方式。<br>第一种方式：点击右上方的设置按钮，进入System settings…在系统栏中选择Software&amp;Updates,将Downloads中的镜像源Others选成Chinese，然后点击右方的选取Select Best Server，等待系统测试选取最佳的节点，再依据后续步骤更新即可。<br>第二种方式：参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学开源软件镜像源</a>。按要求和版本号将配置文件改成清华大学的镜像源即可。</p><h4 id="四、VMWare-Tools的安装"><a href="#四、VMWare-Tools的安装" class="headerlink" title="四、VMWare Tools的安装"></a>四、VMWare Tools的安装</h4><p>此时，Ubuntu已经安装好了。但是，如果要想做到本机和虚拟机能够文件共享，那么还需要下载VMWare Tools。点击：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzWjjf.md.png" alt=""><br>由于我的已经安装过了，所以这里显示为重新安装，后续按照下载。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lz5rx1.png" alt=""><br>点击安装。</p><ol><li>将安装好的压缩包，VMWaretools-XXX(版本号).tar.gz。移动到桌面。</li><li>打开Ubuntu下的终端命令窗口。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd Desktop # 进入桌面</span><br><span class="line">ls  # 查看此压缩包是否在桌面下</span><br><span class="line">tar -xzvf VMWaretools-XXX(版本号).tar.gz # 解压文件</span><br><span class="line">cd VMware-tools-distrib</span><br><span class="line">.&#x2F;vmware-install.pl # 执行vmware-install.pl 进行安装</span><br></pre></td></tr></table></figure><p>依次执行以上命令后，按照提示在终端中输入yes和回车即可。</p><h4 id="五、共享文件夹的设置"><a href="#五、共享文件夹的设置" class="headerlink" title="五、共享文件夹的设置"></a>五、共享文件夹的设置</h4><p>上述步骤中中，安装了VMWare tools，后续就需要设置我们可以共享的文件夹。进入Ubuntu的硬件设置中：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzHHUK.png" alt=""><br>进入共享文件夹。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzH7E6.png" alt=""><br>添加系统文件夹，重启虚拟机。VMWare tools可以使本机和虚拟机之间共享文件；同时可以自动调节虚拟机的分辨率，使得全屏放映使用。</p><h4 id="六、图形界面和字符界面的转换"><a href="#六、图形界面和字符界面的转换" class="headerlink" title="六、图形界面和字符界面的转换"></a>六、图形界面和字符界面的转换</h4><p>首先打开虚拟机中的终端，<code>sudo su</code>进入root模式。</p><ol><li><p>修改grub文件</p><ul><li><p><code>sudo vi /etc/default/grub</code>  </p><ul><li>修改grub文件的三处：  </li></ul><ol><li>将GRUB_CMDLINE_LINUX_DEFAULT=”quiet splash”进行注释，即最前方加#。  </li><li>GRUB_CMDLINE_LINUX=”text”,添加为text，文本。  </li><li>GRUB_TERMINAL=console，取消注释。  </li></ol></li></ul></li></ol><p>最终的修改结果如下图：<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2020/01/17/lzj7VA.png" alt=""><br>保存退出。  </p><ol start="2"><li><code>sudo update-grub</code>更新grub文件。  </li><li>执行<code>sudo systemctl set-default multi-user.target</code> 即将开机默认方式改为字符形界面。  </li><li>重新启动虚拟机。<strong>注意:不要使用reboot</strong><br><strong>总结</strong>:以后两种模式的转化只需要两句终端命令即可。</li></ol><ul><li>图形转字符界面：<code>sudo systemctl set-default multi-user.target</code></li><li>字符转图形界面：<code>sudo systemctl set-default graphical.target</code></li><li>最后重启虚拟机，即可！  </li></ul><h4 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h4><ul><li>Ubuntu安装的镜像网站：  <ul><li>14.04版本：<a href="http://mirrors.aliyun.com/ubuntu-releases/14.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/14.04/</a></li><li>16.04版本：<a href="http://mirrors.aliyun.com/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/16.04/</a></li><li>18.04版本：<a href="http://mirrors.aliyun.com/ubuntu-releases/18.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/18.04/</a>  </li></ul></li><li>清华大学镜像源：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>VMWare FUsion安装地址：<a href="https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_fusion/11_0" target="_blank" rel="noopener">https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_fusion/11_0</a></li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><blockquote><p>[1] <a href="https://blog.csdn.net/u010830004/article/details/79869457" target="_blank" rel="noopener">mac上用VMWare虚拟机装Ubuntu–及Ubuntu安装Vmware Tools</a><br>[2] <a href="https://jingyan.baidu.com/article/574c52195de75a6c8d9dc1b8.html" target="_blank" rel="noopener">如何安装ubuntu系统</a><br>[3] <a href="https://blog.csdn.net/love20165104027/article/details/83377758" target="_blank" rel="noopener">VMware Tools安装</a><br>[4] <a href="https://blog.csdn.net/ibless/article/details/91979711" target="_blank" rel="noopener">Ubuntu16.04 图形界面与字符界面切换</a></font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列之深拷贝/浅拷贝</title>
      <link href="/2019/10/22/%E5%BA%8F%E5%88%97%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/10/22/%E5%BA%8F%E5%88%97%E4%B9%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>在上周的Python科学计算课上，老师讲到了Python序列的浅拷贝以及深拷贝方面的知识，个人觉得说得比较言简意赅了，对于我这个刚入Python的新手来说，也基本可以避免今后变量的赋值使用错乱的问题。</p><p>这里我们简单的将Python中的标准数据类型分为两类：</p><ul><li>不可变数据类型：int、float、string、boolean</li><li>可变（组合）数据类型：列表（list）、字典（dict）、集合(set)</li></ul><p>先举几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># a为上述定义的不可变数据类型</span></span><br><span class="line">b = a</span><br><span class="line">print(<span class="string">'b=&#123;&#125;'</span>.format(b)) <span class="comment"># b = 1</span></span><br><span class="line">--------</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">print(<span class="string">'a = &#123;&#125;,b = &#123;&#125;'</span>.format(a,b)) <span class="comment"># a = 1,b = 2</span></span><br><span class="line"></span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment"># b为上述定义的组合数据类型 </span></span><br><span class="line">d = c</span><br><span class="line">print(<span class="string">'c = &#123;&#125;,d = &#123;&#125;'</span>.format(c,d)) <span class="comment"># c = [1, 2, 3],d = [1, 2, 3]</span></span><br><span class="line">d.append(<span class="number">4</span>) </span><br><span class="line">print(<span class="string">'c = &#123;&#125;,d = &#123;&#125;'</span>.format(c,d)) <span class="comment"># c = [1, 2, 3, 4],d = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>从上述的例子当中看出，在不可变数据类型中，所定义的变量的值在后来改变（这里是b），并不会引起原来赋给它值的那个量的改变（这里是a）；而在组合数据类型中就发生了改变，我们只是将d的值进行了改变，并没有直接改变c的值，最后c的值却也发生了变化。</p><a id="more"></a><p>这里，基本数据变量的赋值其实就是深拷贝；组合数据类型的赋值就是起了一个别名。</p><p>这里先做出<strong>组合数据类型</strong>中赋值、浅拷贝、深拷贝三种的区别：</p><ul><li><p>直接赋值：其实就是对象的引用（即给对象起一个别名）。</p></li><li><p>浅拷贝（copy)：拷贝父对象，不会拷贝对象的内部的子对象。</p></li><li><p>深拷贝（deepcopy):copy模块的deepcopy方法，完全拷贝了父对象及其子对象。</p><p>关于内部子对象的概念，下方会再解释。</p></li></ul><p>接下来我们再看一组图（上课ppt图片）：</p><p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/10/22/KGgqHg.png" alt="赋值引用"></p><p>这里的a = {1:[1,2,3]}字典类型。b = a : 赋值引用，a 和 b 都指向同一个对象。可以看出，a,b此刻都指向同一个对象，所以改变b的内容，就是在改变a,b同时所指向的对象的内容，可以理解成b就是a的一个别名。</p><p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/10/22/KG2kE4.png" alt="浅拷贝"></p><p>这里 a = {1:[1,2,3]} , b = a.copy()，这里就是一种浅拷贝的方式。可以看出a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。所以在这里L,M就是对象当中的一个子对象（[1,2,3]）便是这里的子对象。</p><p>举个上述的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'北京'</span>:<span class="string">'天安门'</span>&#125;</span><br><span class="line">b = copy.copy(a) <span class="comment"># b = &#123;1：[1,2,3],'北京':'天安门'&#125;</span></span><br><span class="line">b[<span class="number">1</span>].append(<span class="number">4</span>) </span><br><span class="line">b[<span class="string">'上海'</span>] = <span class="string">'东方明珠'</span></span><br><span class="line">b[<span class="string">'北京'</span>] = <span class="string">'鸟巢'</span></span><br><span class="line">print(<span class="string">'输出：a = &#123;&#125;,b = &#123;&#125;'</span>.format(a,b))</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">输出：a = &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'北京'</span>: <span class="string">'天安门'</span>&#125;,b = &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'北京'</span>: <span class="string">'鸟巢'</span>, <span class="string">'上海'</span>: <span class="string">'东方明珠'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>b = copy.copy(a)</code> 使得b为单独一个对象，但是它和a的子对象指向统一对象。这里的子对象就是[1,2,3]（列表子对象）。故当改变b中1键对中的值[1,2,3]时，a也会改变（统一子对象)。但向b中添加值时，便不会对a造成影响，因为这是b自身的对象所拥有的值（和a没有关系)。</p><p>那么如何拷贝一个a，但对这个拷贝的对象任意操作时，不会对a产生任何的影响呢？答：采用深拷贝。</p><p>如图:</p><p><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/10/23/KY6iE4.png" alt="深拷贝"></p><p>从图中可以清楚的看出：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]    <span class="comment">#原始对象  </span></span><br><span class="line">b = a                           <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)                <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)            <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line">a.append(<span class="number">5</span>)                     <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)                <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line">print( <span class="string">'a = '</span>, a )</span><br><span class="line">print( <span class="string">'b = '</span>, b )</span><br><span class="line">print( <span class="string">'c = '</span>, c )</span><br><span class="line">print( <span class="string">'d = '</span>, d )</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>] <span class="comment"># 给a起了一个别名b，本质相同，故b和a的变化相同</span></span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]    <span class="comment"># c中子对象发生了变化 --&gt;浅拷贝</span></span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]         <span class="comment"># a的改变和d无关 --&gt;深拷贝</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于组合数据类型：</p><ul><li><p>直接赋值：其实就是对象的引用（别名）</p></li><li><p>浅拷贝（copy)：拷贝父对象，不会拷贝对象的内部的子对象</p></li><li><p>深拷贝（deepcopy):copy模块的deepcopy方法，完全拷贝了父对象及其子对象。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo yilia 主题添加相册功能</title>
      <link href="/2019/08/28/hexo-yilia-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/28/hexo-yilia-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>当我们使用hexo博客框架中的yilia主题时，在我们这一博客页面中，原作者Litten并未帮我们添加相册这一功能。这时，如果想让我们的博客拥有相册的功能，就需要我们自行添加改变、添加主题中的相关参数。从网上百度了很多，看了许多的博客，还是遇到了一些坑爬不过去。最终，还是请教了一个小伙伴才得以解决。</p><h2 id="一、博客页面添加相册"><a href="#一、博客页面添加相册" class="headerlink" title="一、博客页面添加相册"></a>一、博客页面添加相册</h2><p>首先，打开cmd进入blog的source目录下，创建photos文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\&gt;cd blog</span><br><span class="line">E:\blog&gt;cd source</span><br><span class="line">E:\blog\source&gt;hexo new page &quot;photos&quot;</span><br><span class="line">INFO  Created: E:\blog\source\photos\index.md</span><br></pre></td></tr></table></figure><p>删除文件夹中的index.md文件，否则最终生成的是一个单纯的页面。也可以直接进入source文件下创建photos文件夹。</p><a id="more"></a><h2 id="二、创建图片存储仓库"><a href="#二、创建图片存储仓库" class="headerlink" title="二、创建图片存储仓库"></a>二、创建图片存储仓库</h2><p>因为，我们的博客是部署到远端，使得每一个人都能够看到，而图片在远端的展示，可借助于图床。所以，我们可以专门在github上创建一个仓库用于存储图片。仓库的创建就不再一一赘述，只需登录自己的github，new repository即可。这里，我的仓库名为blog-Picture.<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/08/28/mHQKyV.png" alt="个人仓库"><br>在创建完远端仓库后，将本地与github上远端仓库关联，这样我们以后才能够将图片推送到远端。<br>远端仓库与本地仓库关联的方法:<br>打开博客文件夹，在此根目录下，使用git ,即 git Bush Here,然后输入</p><blockquote><p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:chemlez/picture-blog.git</p></blockquote><p>其中clone的仓库换成自己的仓库地址。这样便能使本地与远端关联起立。此刻，会产生一个blog-Picture的文件夹，在此文件夹下分别创建min_photos、photos文件夹。其中，在此photos文件夹下存入一张图片，再将整个内容推送至远端。</p><blockquote><p>$ git add .<br>$ git commit -m “照片存放”<br>$ git push -u origin master </p></blockquote><p>这个时候本地的内容就被推送到了远端。关于git推送远端的用法，可参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440" target="_blank" rel="noopener">廖雪峰的教程</a>。这样后面我们可以用来查看图片的存入地址，来修改我们的ins.js参数。</p><h2 id="三、创建相册布局样式"><a href="#三、创建相册布局样式" class="headerlink" title="三、创建相册布局样式"></a>三、创建相册布局样式</h2><p>在一开始的博客主题clone中，主题yilia并没有相册的版块。但作者<a href="http://litten.me/" target="_blank" rel="noopener">Litten</a>的博客样式中添加了这一版块。所以，我们可以参照原作者的格式进行相关的修改即可。其中的样式参照这里–<a href="https://github.com/ChemLez/ChemLez.github.io/tree/master/photos" target="_blank" rel="noopener">样式参考</a>。下载完之后：<br>1.删除其中所有的.json文件。因为，后面的.json文件是我们自己博客在上传图片时生成的.<br>2.修改index.ejs。这一步很重要，我自己查百度和相关博文时，都没有提到这一步。将其中的href修改成自己的博客地址。当初我就没有修改，最终，显示出来的永远都是原作者Litten的相册.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &lt;div class&#x3D;&quot;instagram itemscope&quot;&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;chemlez.github.io&#x2F;&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;open-ins&quot;&gt;图片正在加载中…&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>3.修改ins.js文件里的render()函数，按照上面的注释提醒，进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改这里render()函数：修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径)</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ChemLez&#x2F;blog-Picture&#x2F;master&#x2F;photos&#x2F;</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ChemLez&#x2F;blog-Picture&#x2F;master&#x2F;min_photos&#x2F;</span><br><span class="line">    var render &#x3D; function render(res) &#123;</span><br><span class="line">      var ulTmpl &#x3D; &quot;&quot;;</span><br><span class="line">      for (var j &#x3D; 0, len2 &#x3D; res.list.length; j &lt; len2; j++) &#123;</span><br><span class="line">        var data &#x3D; res.list[j].arr;</span><br><span class="line">        var liTmpl &#x3D; &quot;&quot;;</span><br><span class="line">        for (var i &#x3D; 0, len &#x3D; data.link.length; i &lt; len; i++) &#123;</span><br><span class="line">          var minSrc &#x3D; &#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ChemLez&#x2F;blog-Picture&#x2F;master&#x2F;min_photos&#x2F;&#39; + data.link[i];</span><br><span class="line">          var src &#x3D; &#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ChemLez&#x2F;blog-Picture&#x2F;master&#x2F;photos&#x2F;&#39; + data.link[i];</span><br><span class="line">          var type &#x3D; data.type[i];</span><br><span class="line">          var target &#x3D; src + (type &#x3D;&#x3D;&#x3D; &#39;video&#39; ? &#39;.mp4&#39; : &#39;.jpg&#39;);</span><br><span class="line">          src +&#x3D; &#39;&#39;;</span><br></pre></td></tr></table></figure><p>这里的地址，就可以查看我们第二步所做的工作。打开github，进入blog-Picture仓库后。点击在第二步中上传的照片。<img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/08/29/mqaudA.png" alt="图片">然后点击Download，此时的浏览框中的地址就是我们所需要的地址。</p><h2 id="四、添加脚本"><a href="#四、添加脚本" class="headerlink" title="四、添加脚本"></a>四、添加脚本</h2><p>这里添加的python脚本主要是用于处理图片。脚本下载-<a href="https://github.com/ChemLez/blog-Picture" target="_blank" rel="noopener">下载地址</a>.<br>因为，当我们点击相册这一页面时，展示在眼前的是一张张缩略图。而当你需要预览具体的某一张图时，其显示的是一张大图。所以，我们的预览图照片大小是经过压缩处理的（使得页面加载快）。当我们具体看某张图片时，再使用原画质的图片。所以，min_photos和photos两个文件夹分别对应着这两种图片。其中，min_photos就是处理过后的压缩图片，而photos就是我们存放的图片。所以，这里的python脚本主要就做着这样的工作。</p><ol><li>将其中的.py文件拷贝至本地仓库blog-Picture文件夹中.</li><li>根据脚本文件，图片的命名规则为：2019-10-21_xxx.jpg/png.</li><li>将图片<a href="https://github.com/ChemLez/ChemLez.github.io/blob/master/assets/img/empty.png" target="_blank" rel="noopener">empty.png</a>下载放入博客目录下的assets/img文件夹中.</li><li>打开tool.py文件,修改def handle_photo():<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;E:&#x2F;blog&#x2F;source&#x2F;photos&#x2F;data.json&quot;, &quot;w&quot;) as fp:</span><br></pre></td></tr></table></figure>将其中的的地址，换成你将要生成data.json的位置，就是在第一步中，我们删除的.json文件夹的目录地址。每次，进行tool.py脚本时，都会产生data.json文件，用于存储我们图片的信息。</li></ol><h2 id="五、运行"><a href="#五、运行" class="headerlink" title="五、运行"></a>五、运行</h2><p>1.首先将用于测试的图片名改成上述的命名规则的名字,推送至github远端，进行修改.<br>2.打开终端命令窗口cmd.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">cd blog-Picture &#x2F;&#x2F;用于进入blog-Picture文件夹</span><br><span class="line">python tool.py &#x2F;&#x2F;python脚本文件的运行</span><br><span class="line">第二句的运行这里可能会报错 &#96;no module named PIL&#96;</span><br><span class="line">然后输入：</span><br><span class="line">pip install pillow</span><br><span class="line">可能出现权限不足的情况，按照下方出现的英文，加上权限进行下载。即：一路按照下方的英文,加权限进行下载.</span><br></pre></td></tr></table></figure><p>3.hexo s.预览查看。这里我将video功能隐去了，最初的photos旁边还有一个video功能。<br><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/placeholder/d570170f4f12e1ee829ca0e85a7dffeb77343a.svg" data-original="https://s2.ax1x.com/2019/08/29/mq6fkF.png" alt=""><br>4.在最初的photos下载中，有个videos.ejs文件，如果想引入一些视频，可将其中的链接即src，视频名进行修改.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;h1&gt;指弹_女儿情&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&#x2F;&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;video-container&quot;&gt;</span><br><span class="line">        &lt;iframe height&#x3D;&quot;80%&quot; width&#x3D;&quot;80%&quot; src&#x3D;&quot;https:&#x2F;&#x2F;player.youku.com&#x2F;embed&#x2F;XMjUzMzY4OTM3Ng&#x3D;&#x3D;&quot; frameborder&#x3D;0 allowfullscreen&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>如果不想用这一功能，将以下标签注释.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class&#x3D;&quot;photos-btn&quot; href&#x3D;&quot;&#x2F;photos&#x2F;videos.html&quot;&gt;Video&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ol><li>每次将需要上传的图片，放入到blog-Picture中的photos文件夹.图片的命名一定要遵循上述说的命名规则.<strong>注意</strong>：如果想让多张图片归类在页面中的某一个年、月份下，必须使得日期一模一样，只能修改xxx。如果命名中，年、月相同，而日期不同便会在相册页面额外生成一个list，其表头相同。</li><li>cmd命令窗口进入blog-Picture,再进行python tool.py，运行脚本.</li><li>将图片推送到github远端仓库，产生链接.</li><li>hexo s 进入本地窗口预览，没有问题后：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F;清除页面缓存</span><br><span class="line">hexo g &#x2F;&#x2F;用于生成改动的文件</span><br><span class="line">hexo d &#x2F;&#x2F;部署到远端网站</span><br></pre></td></tr></table></figure><btns rounded grid5><a href='https://Chemlez.github.io/photos/' target="_blank" rel="noopener"><i class='fas fa-book'></i>最终效果</a></a></btns></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] hexo Yilia 主题如何添加相册功能:<a href="https://www.jianshu.com/p/a9f309aaa0e0" target="_blank" rel="noopener">https://www.jianshu.com/p/a9f309aaa0e0</a><br>[2] hexo yilia 主题如何添加相册:<a href="https://blog.csdn.net/qq_40651535/article/details/95061281" target="_blank" rel="noopener">https://blog.csdn.net/qq_40651535/article/details/95061281</a><br>[3] Hexo+Github实现相册功能:<a href="http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
